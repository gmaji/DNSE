package sna.physica.ranking;
import java.util.Date;
/**
 * Identifying the node spreading influence in networks is an important task to optimally
use the network structure and ensure the more efficient spreading in information. In this
paper, by taking into account the shortest distance between a target node and the node
set with the highest k-core value, we present an improved method to generate the ranking
list to evaluate the node spreading influence. Comparing with the epidemic process results
for four real networks and the Barabasi-Albert network, the parameterless method could
identify the node spreading influence more accurately than the ones generated by the
degree k, closeness centrality, k-shell and mixed degree decomposition methods. This work
would be helpful for deeply understanding the node importance of a network.
* 
* Paper: Liu, Jian-Guo, Zhuo-Ming Ren, and Qiang Guo. "Ranking the spreading influence in complex networks." 
* Physica A: Statistical Mechanics and its Applications 392, no. 18 (2013): 4154-4159.
 */
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import sna.physica.graph.IndexedGraph;
import edu.uci.ics.jung.algorithms.shortestpath.DijkstraDistance;
import edu.uci.ics.jung.graph.Graph;
import edu.uci.ics.jung.graph.UndirectedSparseGraph;

public class ImprovedRanker extends Ranker {

	public ImprovedRanker(IndexedGraph graph) {
		super(graph);
	}
	
	@Override
	public void evaluate() {
		System.out.println("START :::: ImprovedRanker.evaluate():: Time: "+new Date());
		preProcessing();

		KShellRanker kshellRanker = new KShellRanker(graph);
		kshellRanker.evaluate();
		
		long[] thetaMap = improved(kshellRanker);
		
		for (int v=0; v<graph.getVertexCount(); v++) {
			long value = thetaMap[v];
			nodeValueMap[v] = value;
		}
		
		postProcessingReverse();
		System.out.println("END :::: ImprovedRanker.evaluate():: Time: "+new Date());
	}

	
	public void evaluate(KShellRanker kshellRanker) {
		System.out.println("START :::: ImprovedRanker.evaluate():: Time: "+new Date());
		preProcessing();

		long[] thetaMap = improved(kshellRanker);
		
		for (int v=0; v<graph.getVertexCount(); v++) {
			long value = thetaMap[v];
			nodeValueMap[v] = value;
		}
		
		postProcessingReverse();
		System.out.println("END :::: ImprovedRanker.evaluate():: Time: "+new Date());
	}
	private long[] improved(KShellRanker kshellRanker) {
		
		Graph<Integer, Integer> g = new UndirectedSparseGraph<Integer, Integer>();
		for (int vi=0; vi<graph.getVertexCount(); vi++) {
			for (int vj: graph.getNeighbors(vi)) {
				g.addEdge(g.getEdgeCount(), vi, vj);
			}
		}

		DijkstraDistance<Integer, Integer> dijkstra = new DijkstraDistance<Integer, Integer>(g);
		dijkstra.enableCaching(true);

		Set<Integer> coreSet = kshellRanker.getRankIndexSet(1);

		Map<Integer, Map<Integer, Number>> distanceMap = new HashMap<Integer, Map<Integer, Number>>();

//		int count = 1;
		for (int core: coreSet) {
//			System.err.println("count"+count++);
			distanceMap.put(core, dijkstra.getDistanceMap(core));
		}
		
		long[] theta = new long[g.getVertexCount()];
		
		int isolated = 0;
		int ksMax = (int)kshellRanker.getRankValue(1);
		for (int v: g.getVertices()) {
			long ks = kshellRanker.getNodeValue(v);
			int distance = 0;
			for (int core: coreSet) {
				Number shortest = distanceMap.get(core).get(v);
				if (shortest == null) {
					distance += (int)Math.log(graph.getVertexCount());
					//System.err.println("Hitting isolated!!!! -> " + isolated++);
				} else {
					distance += shortest.intValue();
				}
			}
			long value = distance * (ksMax - ks + 1);
			theta[v] = value;
		}

		return theta;
		
//		int[] thetaRanked = new int[theta.length];
//
//		int kshellInterval = 0;
//		for (int rank=1; rank<=kshellRanker.length(); rank++) {
//			int maxValue = 0;
//			for (int v: kshellRanker.getRankIndexSet(rank)) {
//				int value = kshellInterval + theta[v];
//				thetaRanked[v] = value;
//				if (maxValue < value) {
//					maxValue = value;
//				}
//			}
//			kshellInterval = maxValue + 1;
//		}
//		
//		return thetaRanked;
	}
	
}
